# class guidelines

## 概要

### 封装

把相关的数据结构组织到 struct 或 class 中

在类中体现出接口(public)和实现(private)的区别

尽量减少成员的暴露


### class or struct

如果数据结构具有不变式, 使用 class, 否则(数据成员可以独立变化), 使用 struct

如果有任何非公开成员, 使用 class 而不是 struct

### 辅助函数和成员

仅当函数需要直接访问类的内部表示时, 才把它变成成员

将辅助函数和它支持的类放在同一个 namespace 下

### bad taste

不要在一条语句中定义类的同时声明该类型的变量

## 具体类型

具体类型: 最简单的一种类, 值类型, 不属于某个类型层次结构的一部分

规范类型： 行为上类似于 int 的类型, 因此需要支持拷贝和赋值, 相等比较, 可交换等操作, 具体需要实现以下方法

- 默认构造
- 拷贝构造
- 移动构造
- 拷贝赋值
- 移动赋值
- 析构
- 交换操作
- 相等运算符

优先使用具体类型
- 具体类型更容易实现, 更小
- 不用担心继承, 虚性, 引用或指针, 内存分配和释放
- 不会有虚派发, 没有运行时开销

让具体类型规范化

## 构造, 析构, 赋值

六大特殊成员函数

- 默认构造
- 拷贝构造
- 移动构造
- 拷贝赋值
- 移动赋值
- 析构

编译器可以为这六个函数生成默认实现

默认操作: 拷贝, 移动, 析构函数

### 预置操作

如果能避免定义默认操作, 那就这么做(零法则)

如果定义或 delete 了任何默认操作, 那就对所有的默认操作进行定义或 delete
- 被称作"六法则", 或"五法则", 因为构造函数比较特殊, 被排除在外
- 如果不定义任何"六大", 则编译器会为"六大"都生成默认实现
- 不管用户是否定义构造函数, 不影响编译器为"五大"生成默认实现
- 只要定义了任何构造函数, 编译器不再为默认构造函数生成默认实现

让默认操作保持一致
- 如果要自己实现, 都自己实现, 不要一部分自己实现, 一部分 =default

### 构造函数

构造函数应当创建完全初始化的对象

如果构造函数无法构造有效对象, 抛出异常

当一个类的所有构造函数有共同的操作时, 使用委托构造函数

确保可拷贝的类有默认构造函数
- STL 容器的许多构造函数要求用户提供的类型有默认构造函数

不要定义仅初始化数据成员的默认构造函数, 而应该使用成员初始化器
- 成员初始化器定义默认行为, 明确定义的构造函数只用来改变默认行为

把单参数构造函数声明为 explicit
- 没有 explicit 的单参数构造函数实际上是个转换函数

按照成员声明的顺序初始化成员变量

使用常量来初始化时, 优先选择类内初始化器, 而不是构造函数成员初始化

构造函数优先使用初始化而不是赋值

使用继承构造函数将构造函数导入不需要进一步显示初始化的派生类中


