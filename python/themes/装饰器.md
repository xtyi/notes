# 装饰器

函数装饰器允许在源码中"标记"函数，以某种方式增强函数的行为

装饰器是一种可调用对象，其参数是被装饰的函数

装饰器可能会对被装饰的函数做些处理，然后返回函数，或者把函数替换成另一个函数或可调用对象

假如有一个名为 `decorate` 的装饰器，以下两种写法完全一样

```python
@decorate
def target()
	print("running target()")
```

```python
def target():
	print("running target()")

target = decorate(target)
```

装饰器只是语法糖，有以下几个基本性质
- 装饰器是一个可调用对象
- 装饰器可以把被装饰的函数替换成别的函数
- 装饰器在加载模块时立即执行

下面的例子展示被装饰的函数被替换掉

```python
def deco(func):
	def inner():
		print("running inner()")
	return inner

@deco
def target():
	print("running target()")

target() # running inner()
```

装饰器在导入模块时立即执行

```python
registry = []

def register(func):
	print(f"running register({func})")
	registry.append(func)
	return func

@register
def f1():
	print("running f1()")

@register
def f2():
	print("running f2()")

def f3():
	print("running f3()")

def main():
	print("running main()")
	print("registry ->", registry)
	f1()
	f2()
	f3()

if __name__ == "__main__":
	main()
```

输出

```
running register(<function f1 at 0x7f2483ffa560>)
running register(<function f2 at 0x7f2483ffa5f0>)
running main()
registry -> [<function f1 at 0x7f2483ffa560>, <function f2 at 0x7f2483ffa5f0>]
running f1()
running f2()
running f3()
```


